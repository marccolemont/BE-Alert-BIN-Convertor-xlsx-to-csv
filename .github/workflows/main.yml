name: Build BIN-Convertor (Win + macOS + Pi64) – Signed Version

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

permissions:
  id-token: write
  contents: read

jobs:
  build:
    name: Build (${{ matrix.name }})
    runs-on: ${{ matrix.runner }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: windows-x64
            runner: windows-latest
            kind: windows
            target: x86_64-pc-windows-msvc

          - name: macos-app
            runner: macos-latest
            kind: macos

          - name: raspberrypi-64
            runner: ubuntu-latest
            kind: pi
            target: aarch64-unknown-linux-gnu

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        if: matrix.kind != 'macos'
        with:
          targets: ${{ matrix.target }}

      - uses: dtolnay/rust-toolchain@stable
        if: matrix.kind == 'macos'
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      # ================= WINDOWS =================
      - name: Build (Windows x64)
        if: matrix.kind == 'windows'
        run: cargo build --release --target ${{ matrix.target }}

      - name: Azure login (OIDC)
        if: matrix.kind == 'windows'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Sign Windows exe (Azure Trusted Signing)
        if: matrix.kind == 'windows'
        uses: azure/trusted-signing-action@v0
        with:
          endpoint: ${{ secrets.TRUSTED_SIGNING_ENDPOINT }}
          trusted-signing-account-name: ${{ secrets.TRUSTED_SIGNING_ACCOUNT }}
          certificate-profile-name: ${{ secrets.TRUSTED_SIGNING_PROFILE }}

          files-folder: ${{ github.workspace }}\\target\\${{ matrix.target }}\\release
          files-folder-filter: exe
          files-folder-recurse: false

          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

          exclude-environment-credential: true
          exclude-managed-identity-credential: true
          exclude-shared-token-cache-credential: true
          exclude-visual-studio-credential: true
          exclude-visual-studio-code-credential: true
          exclude-azure-developer-cli-credential: true
          exclude-interactive-browser-credential: true

      - name: Upload (Windows exe)
        if: matrix.kind == 'windows'
        uses: actions/upload-artifact@v4
        with:
          name: BIN-Convertor-windows-x64
          path: target/${{ matrix.target }}/release/*.exe

      # ================= macOS =================
      - name: Install cargo-bundle
        if: matrix.kind == 'macos'
        run: cargo install cargo-bundle

      - name: Build (macOS arm64 + x86_64)
        if: matrix.kind == 'macos'
        env:
          MACOSX_DEPLOYMENT_TARGET: "12.0"
        run: |
          cargo build --release --target aarch64-apple-darwin
          cargo build --release --target x86_64-apple-darwin

      - name: Bundle (macOS) + make universal binary
        if: matrix.kind == 'macos'
        env:
          MACOSX_DEPLOYMENT_TARGET: "12.0"
        run: |
          set -euo pipefail
          # Create the .app bundle (cargo-bundle uses the host arch; we'll replace the binary with a universal one)
          cargo bundle --release

          APP=$(ls -d target/release/bundle/osx/*.app | head -n 1)
          if [ -z "${APP:-}" ] || [ ! -d "$APP" ]; then
            echo "ERROR: No .app bundle found at target/release/bundle/osx/*.app" >&2
            exit 1
          fi

          # Expect exactly one executable inside Contents/MacOS
          mapfile -t MACOS_BINS < <(find "$APP/Contents/MacOS" -maxdepth 1 -type f ! -name ".*" -print)
          if [ "${#MACOS_BINS[@]}" -ne 1 ]; then
            echo "ERROR: Expected exactly 1 binary in $APP/Contents/MacOS, found ${#MACOS_BINS[@]}" >&2
            printf '%s\n' "${MACOS_BINS[@]}" >&2
            exit 1
          fi

          BIN_PATH="${MACOS_BINS[0]}"
          BIN_NAME=$(basename "$BIN_PATH")

          ARM_BIN="target/aarch64-apple-darwin/release/$BIN_NAME"
          X64_BIN="target/x86_64-apple-darwin/release/$BIN_NAME"

          if [ ! -f "$ARM_BIN" ]; then
            echo "ERROR: arm64 build not found: $ARM_BIN" >&2
            exit 1
          fi
          if [ ! -f "$X64_BIN" ]; then
            echo "ERROR: x86_64 build not found: $X64_BIN" >&2
            exit 1
          fi

          echo "Bundled app: $APP"
          echo "Binary name: $BIN_NAME"

          # Replace the app binary with a universal (fat) binary
          lipo -create "$ARM_BIN" "$X64_BIN" -output "$BIN_PATH"
          chmod +x "$BIN_PATH"

          # Fail fast if the output is not universal
          LIPO_INFO=$(lipo -info "$BIN_PATH" || true)
          echo "$LIPO_INFO"
          echo "$LIPO_INFO" | grep -q "x86_64" || { echo "ERROR: universal binary missing x86_64" >&2; exit 1; }
          echo "$LIPO_INFO" | grep -q "arm64"  || { echo "ERROR: universal binary missing arm64" >&2; exit 1; }

          # Ensure the bundle declares macOS 12.0 minimum
          /usr/libexec/PlistBuddy -c "Set :LSMinimumSystemVersion 12.0" "$APP/Contents/Info.plist" || \
          /usr/libexec/PlistBuddy -c "Add :LSMinimumSystemVersion string 12.0" "$APP/Contents/Info.plist"

          # Show the architectures to confirm universal and codesign details
          file "$BIN_PATH"
          codesign -dv --verbose=4 "$APP" 2>&1 | sed -n '1,40p'

      - name: Import Developer ID certificate
        if: matrix.kind == 'macos'
        env:
          CERT_B64: ${{ secrets.MACOS_CERT_P12_B64 }}
          CERT_PASSWORD: ${{ secrets.MACOS_CERT_P12_PASSWORD }}
        run: |
          python3 - <<'PY'
          import os, base64, re
          b64 = os.environ.get('CERT_B64','')
          b64 = re.sub(r"\s+", "", b64)
          data = base64.b64decode(b64)
          with open('developerid.p12','wb') as f:
              f.write(data)
          print(f"Wrote developerid.p12 ({len(data)} bytes)")
          PY

          # Validate the p12 (fails fast if password is wrong or file is corrupted)
          openssl pkcs12 -in developerid.p12 -passin pass:"$CERT_PASSWORD" -noout

          # Create and configure a temporary keychain for codesign
          security create-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security unlock-keychain -p "" build.keychain

          # Make sure our keychain is in the search path and default
          security list-keychains -d user -s build.keychain
          security default-keychain -s build.keychain

          # Import the Developer ID certificate + private key
          security import developerid.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security

          # Allow codesign and related tools to access the private key non-interactively
          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain

          # Debug (safe): show available signing identities
          security find-identity -v -p codesigning build.keychain || true

      - name: Codesign macOS app (Developer ID)
        if: matrix.kind == 'macos'
        env:
          SIGN_ID: ${{ secrets.DEVELOPERID_APPLE }}
        run: |
          APP=$(ls -d target/release/bundle/osx/*.app)
          security list-keychains -d user -s build.keychain
          codesign --force --deep --options runtime --timestamp --sign "$SIGN_ID" "$APP"
          codesign --verify --deep --strict --verbose=2 "$APP"

      - name: Notarize and staple macOS app
        if: matrix.kind == 'macos'
        env:
          KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
          KEY_P8_B64: ${{ secrets.APPLE_API_KEY_P8_B64 }}
        run: |
          # Write the API private key. Supports either base64-encoded content OR raw PEM stored in the secret.
          python3 - <<'PY'
          import os, base64, re
          s = os.environ.get('KEY_P8_B64','')
          if 'BEGIN PRIVATE KEY' in s:
              data = (s.strip() + '\n').encode('utf-8')
          else:
              b64 = re.sub(r"\s+", "", s)
              data = base64.b64decode(b64)
          with open('AuthKey.p8','wb') as f:
              f.write(data)
          print(f"Wrote AuthKey.p8 ({len(data)} bytes)")
          PY

          mkdir -p "$HOME/private_keys"
          cp AuthKey.p8 "$HOME/private_keys/AuthKey_${KEY_ID}.p8"

          APP=$(ls -d target/release/bundle/osx/*.app)
          ditto -c -k --sequesterRsrc --keepParent "$APP" app.zip

          xcrun notarytool submit app.zip \
            --key "$HOME/private_keys/AuthKey_${KEY_ID}.p8" \
            --key-id "$KEY_ID" \
            --issuer "$ISSUER_ID" \
            --wait

          xcrun stapler staple "$APP"

      - name: Upload (macOS app – signed)
        if: matrix.kind == 'macos'
        uses: actions/upload-artifact@v4
        with:
          name: BIN-Convertor-macos-app
          path: target/release/bundle/osx/*.app

      # ================= PI =================
      - name: Setup QEMU (for cross)
        if: matrix.kind == 'pi'
        uses: docker/setup-qemu-action@v3

      - name: Install cross
        if: matrix.kind == 'pi'
        run: cargo install cross --locked

      - name: Build (Raspberry Pi 64-bit)
        if: matrix.kind == 'pi'
        run: cross build --release --target ${{ matrix.target }}

      - name: Upload (Pi 64 binary)
        if: matrix.kind == 'pi'
        uses: actions/upload-artifact@v4
        with:
          name: BIN-Convertor-raspberrypi-64
          path: target/${{ matrix.target }}/release/*