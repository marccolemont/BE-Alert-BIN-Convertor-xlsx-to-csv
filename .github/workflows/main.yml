name: Build BIN-Convertor (Win + macOS + Pi64) – Signed Version

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

jobs:
  build:
    name: Build (${{ matrix.name }})
    runs-on: ${{ matrix.runner }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: windows-x64
            runner: windows-latest
            kind: windows
            target: x86_64-pc-windows-msvc

          - name: macos-app
            runner: macos-latest
            kind: macos

          - name: raspberrypi-64
            runner: ubuntu-latest
            kind: pi
            target: aarch64-unknown-linux-gnu

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # ================= WINDOWS =================
      - name: Build (Windows x64)
        if: matrix.kind == 'windows'
        run: cargo build --release --target ${{ matrix.target }}

      - name: Upload (Windows exe)
        if: matrix.kind == 'windows'
        uses: actions/upload-artifact@v4
        with:
          name: BIN-Convertor-windows-x64
          path: target/${{ matrix.target }}/release/*.exe

      # ================= macOS =================
      - name: Install cargo-bundle
        if: matrix.kind == 'macos'
        run: cargo install cargo-bundle

      - name: Bundle (macOS)
        if: matrix.kind == 'macos'
        run: cargo bundle --release

      - name: Import Developer ID certificate
        if: matrix.kind == 'macos'
        env:
          CERT_B64: ${{ secrets.MACOS_CERT_P12_B64 }}
          CERT_PASSWORD: ${{ secrets.MACOS_CERT_P12_PASSWORD }}
        run: |
          python3 - <<'PY'
          import os, base64, re
          b64 = os.environ.get('CERT_B64','')
          b64 = re.sub(r"\s+", "", b64)
          data = base64.b64decode(b64)
          with open('developerid.p12','wb') as f:
              f.write(data)
          print(f"Wrote developerid.p12 ({len(data)} bytes)")
          PY

          # Validate the p12 (fails fast if password is wrong or file is corrupted)
          openssl pkcs12 -in developerid.p12 -passin pass:"$CERT_PASSWORD" -noout

          # Create and configure a temporary keychain for codesign
          security create-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security unlock-keychain -p "" build.keychain

          # Make sure our keychain is in the search path and default
          security list-keychains -d user -s build.keychain
          security default-keychain -s build.keychain

          # Import the Developer ID certificate + private key
          security import developerid.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security

          # Allow codesign and related tools to access the private key non-interactively
          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain

          # Debug (safe): show available signing identities
          security find-identity -v -p codesigning build.keychain || true

      - name: Codesign macOS app (Developer ID)
        if: matrix.kind == 'macos'
        env:
          SIGN_ID: ${{ secrets.DEVELOPERID_APPLE }}
        run: |
          APP=$(ls -d target/release/bundle/osx/*.app)
          security list-keychains -d user -s build.keychain
          codesign --force --deep --options runtime --timestamp --sign "$SIGN_ID" "$APP"
          codesign --verify --deep --strict --verbose=2 "$APP"

      - name: Notarize and staple macOS app
        if: matrix.kind == 'macos'
        env:
          KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
          KEY_P8_B64: ${{ secrets.APPLE_API_KEY_P8_B64 }}
        run: |
          # Write the API private key. Supports either base64-encoded content OR raw PEM stored in the secret.
          python3 - <<'PY'
          import os, base64, re
          s = os.environ.get('KEY_P8_B64','')
          if 'BEGIN PRIVATE KEY' in s:
              data = (s.strip() + '\n').encode('utf-8')
          else:
              b64 = re.sub(r"\s+", "", s)
              data = base64.b64decode(b64)
          with open('AuthKey.p8','wb') as f:
              f.write(data)
          print(f"Wrote AuthKey.p8 ({len(data)} bytes)")
          PY

          mkdir -p "$HOME/private_keys"
          cp AuthKey.p8 "$HOME/private_keys/AuthKey_${KEY_ID}.p8"

          APP=$(ls -d target/release/bundle/osx/*.app)
          ditto -c -k --sequesterRsrc --keepParent "$APP" app.zip

          xcrun notarytool submit app.zip \
            --key "$HOME/private_keys/AuthKey_${KEY_ID}.p8" \
            --key-id "$KEY_ID" \
            --issuer "$ISSUER_ID" \
            --wait

          xcrun stapler staple "$APP"

      - name: Upload (macOS app – signed)
        if: matrix.kind == 'macos'
        uses: actions/upload-artifact@v4
        with:
          name: BIN-Convertor-macos-app
          path: target/release/bundle/osx/*.app

      # ================= PI =================
      - name: Setup QEMU (for cross)
        if: matrix.kind == 'pi'
        uses: docker/setup-qemu-action@v3

      - name: Install cross
        if: matrix.kind == 'pi'
        run: cargo install cross --locked

      - name: Build (Raspberry Pi 64-bit)
        if: matrix.kind == 'pi'
        run: cross build --release --target ${{ matrix.target }}

      - name: Upload (Pi 64 binary)
        if: matrix.kind == 'pi'
        uses: actions/upload-artifact@v4
        with:
          name: BIN-Convertor-raspberrypi-64
          path: target/${{ matrix.target }}/release/*